{"ast":null,"code":"import _asyncToGenerator from \"/Users/advityasood/jude_anyft/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport WalletConnect from \"@walletconnect/client\";\nimport QRCodeModal from \"@walletconnect/qrcode-modal\";\nimport HttpConnection from \"@walletconnect/http-connection\";\nimport { payloadId, signingMethods, parsePersonalSign, getRpcUrl } from \"@walletconnect/utils\";\n\nconst ProviderEngine = require(\"web3-provider-engine\");\n\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\n\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\n\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\n\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\n\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\n\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\n\nclass WalletConnectProvider extends ProviderEngine {\n  constructor(opts) {\n    var _this;\n\n    super({\n      pollingInterval: opts.pollingInterval || 8000\n    });\n    _this = this;\n    this.bridge = \"https://bridge.walletconnect.org\";\n    this.qrcode = true;\n    this.qrcodeModal = QRCodeModal;\n    this.qrcodeModalOptions = undefined;\n    this.rpc = null;\n    this.infuraId = \"\";\n    this.http = null;\n    this.isConnecting = false;\n    this.connected = false;\n    this.connectCallbacks = [];\n    this.accounts = [];\n    this.chainId = 1;\n    this.rpcUrl = \"\";\n    this.enable = /*#__PURE__*/_asyncToGenerator(function* () {\n      const wc = yield _this.getWalletConnector();\n\n      if (wc) {\n        _this.start();\n\n        _this.subscribeWalletConnector();\n\n        return wc.accounts;\n      } else {\n        throw new Error(\"Failed to connect to WalleConnect\");\n      }\n    });\n\n    this.request = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (payload) {\n        return _this.send(payload);\n      });\n\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    this.send = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator(function* (payload, callback) {\n        if (typeof payload === \"string\") {\n          const method = payload;\n          let params = callback;\n\n          if (method === \"personal_sign\") {\n            params = parsePersonalSign(params);\n          }\n\n          return _this.sendAsyncPromise(method, params);\n        }\n\n        payload = Object.assign({\n          id: payloadId(),\n          jsonrpc: \"2.0\"\n        }, payload);\n\n        if (payload.method === \"personal_sign\") {\n          payload.params = parsePersonalSign(payload.params);\n        }\n\n        if (callback) {\n          _this.sendAsync(payload, callback);\n\n          return;\n        }\n\n        return _this.sendAsyncPromise(payload.method, payload.params);\n      });\n\n      return function (_x2, _x3) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n\n    this.onConnect = callback => {\n      this.connectCallbacks.push(callback);\n    };\n\n    this.triggerConnect = result => {\n      if (this.connectCallbacks && this.connectCallbacks.length) {\n        this.connectCallbacks.forEach(callback => callback(result));\n      }\n    };\n\n    this.bridge = opts.connector ? opts.connector.bridge : opts.bridge || \"https://bridge.walletconnect.org\";\n    this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n    this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;\n    this.qrcodeModalOptions = opts.qrcodeModalOptions;\n    this.wc = opts.connector || new WalletConnect({\n      bridge: this.bridge,\n      qrcodeModal: this.qrcode ? this.qrcodeModal : undefined,\n      qrcodeModalOptions: this.qrcodeModalOptions,\n      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,\n      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,\n      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta\n    });\n    this.rpc = opts.rpc || null;\n\n    if (!this.rpc && (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n      throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n    }\n\n    this.infuraId = opts.infuraId || \"\";\n    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;\n    this.initialize();\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  get connector() {\n    return this.wc;\n  }\n\n  get walletMeta() {\n    return this.wc.peerMeta;\n  }\n\n  disconnect() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.close();\n    })();\n  }\n\n  close() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const wc = yield _this3.getWalletConnector({\n        disableSessionCreation: true\n      });\n      yield wc.killSession();\n      yield _this3.onDisconnect();\n    })();\n  }\n\n  handleRequest(payload) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        let response;\n        let result = null;\n        const wc = yield _this4.getWalletConnector();\n\n        switch (payload.method) {\n          case \"wc_killSession\":\n            yield _this4.close();\n            result = null;\n            break;\n\n          case \"eth_accounts\":\n            result = wc.accounts;\n            break;\n\n          case \"eth_coinbase\":\n            result = wc.accounts[0];\n            break;\n\n          case \"eth_chainId\":\n            result = wc.chainId;\n            break;\n\n          case \"net_version\":\n            result = wc.chainId;\n            break;\n\n          case \"eth_uninstallFilter\":\n            _this4.sendAsync(payload, _ => _);\n\n            result = true;\n            break;\n\n          default:\n            response = yield _this4.handleOtherRequests(payload);\n        }\n\n        if (response) {\n          return response;\n        }\n\n        return _this4.formatResponse(payload, result);\n      } catch (error) {\n        _this4.emit(\"error\", error);\n\n        throw error;\n      }\n    })();\n  }\n\n  handleOtherRequests(payload) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n        return _this5.handleReadRequests(payload);\n      }\n\n      const wc = yield _this5.getWalletConnector();\n      const result = yield wc.sendCustomRequest(payload);\n      return _this5.formatResponse(payload, result);\n    })();\n  }\n\n  handleReadRequests(payload) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this6.http) {\n        const error = new Error(\"HTTP Connection not available\");\n\n        _this6.emit(\"error\", error);\n\n        throw error;\n      }\n\n      return _this6.http.send(payload);\n    })();\n  }\n\n  formatResponse(payload, result) {\n    return {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      result: result\n    };\n  }\n\n  getWalletConnector(opts = {}) {\n    const {\n      disableSessionCreation = false\n    } = opts;\n    return new Promise((resolve, reject) => {\n      const wc = this.wc;\n\n      if (this.isConnecting) {\n        this.onConnect(x => resolve(x));\n      } else if (!wc.connected && !disableSessionCreation) {\n        this.isConnecting = true;\n        wc.on(\"modal_closed\", () => {\n          reject(new Error(\"User closed modal\"));\n        });\n        wc.createSession({\n          chainId: this.chainId\n        }).then(() => {\n          wc.on(\"connect\", (error, payload) => {\n            if (error) {\n              this.isConnecting = false;\n              return reject(error);\n            }\n\n            this.isConnecting = false;\n            this.connected = true;\n\n            if (payload) {\n              this.updateState(payload.params[0]);\n            }\n\n            this.emit(\"connect\");\n            this.triggerConnect(wc);\n            resolve(wc);\n          });\n        }).catch(error => {\n          this.isConnecting = false;\n          reject(error);\n        });\n      } else {\n        if (!this.connected) {\n          this.connected = true;\n          this.updateState(wc.session);\n        }\n\n        resolve(wc);\n      }\n    });\n  }\n\n  subscribeWalletConnector() {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      const wc = yield _this7.getWalletConnector();\n      wc.on(\"disconnect\", error => {\n        if (error) {\n          _this7.emit(\"error\", error);\n\n          return;\n        }\n\n        _this7.onDisconnect();\n      });\n      wc.on(\"session_update\", (error, payload) => {\n        if (error) {\n          _this7.emit(\"error\", error);\n\n          return;\n        }\n\n        _this7.updateState(payload.params[0]);\n      });\n    })();\n  }\n\n  onDisconnect() {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this8.stop();\n\n      _this8.emit(\"close\", 1000, \"Connection closed\");\n\n      _this8.emit(\"disconnect\", 1000, \"Connection disconnected\");\n\n      _this8.connected = false;\n    })();\n  }\n\n  updateState(sessionParams) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        accounts,\n        chainId,\n        networkId,\n        rpcUrl\n      } = sessionParams;\n\n      if (!_this9.accounts || accounts && _this9.accounts !== accounts) {\n        _this9.accounts = accounts;\n\n        _this9.emit(\"accountsChanged\", accounts);\n      }\n\n      if (!_this9.chainId || chainId && _this9.chainId !== chainId) {\n        _this9.chainId = chainId;\n\n        _this9.emit(\"chainChanged\", chainId);\n      }\n\n      if (!_this9.networkId || networkId && _this9.networkId !== networkId) {\n        _this9.networkId = networkId;\n\n        _this9.emit(\"networkChanged\", networkId);\n      }\n\n      _this9.updateRpcUrl(_this9.chainId, rpcUrl || \"\");\n    })();\n  }\n\n  updateRpcUrl(chainId, rpcUrl = \"\") {\n    const rpc = {\n      infuraId: this.infuraId,\n      custom: this.rpc || undefined\n    };\n    rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);\n\n    if (rpcUrl) {\n      this.rpcUrl = rpcUrl;\n      this.updateHttpConnection();\n    } else {\n      this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n    }\n  }\n\n  updateHttpConnection() {\n    if (this.rpcUrl) {\n      this.http = new HttpConnection(this.rpcUrl);\n      this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n      this.http.on(\"error\", error => this.emit(\"error\", error));\n    }\n  }\n\n  sendAsyncPromise(method, params) {\n    return new Promise((resolve, reject) => {\n      this.sendAsync({\n        id: payloadId(),\n        jsonrpc: \"2.0\",\n        method,\n        params: params || []\n      }, (error, response) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(response.result);\n      });\n    });\n  }\n\n  initialize() {\n    var _this10 = this;\n\n    this.updateRpcUrl(this.chainId);\n    this.addProvider(new FixtureSubprovider({\n      eth_hashrate: \"0x00\",\n      eth_mining: false,\n      eth_syncing: true,\n      net_listening: true,\n      web3_clientVersion: `WalletConnect/v1.x.x/javascript`\n    }));\n    this.addProvider(new CacheSubprovider());\n    this.addProvider(new SubscriptionsSubprovider());\n    this.addProvider(new FilterSubprovider());\n    this.addProvider(new NonceSubprovider());\n    this.addProvider(new HookedWalletSubprovider(this.configWallet()));\n    this.addProvider({\n      handleRequest: function () {\n        var _ref4 = _asyncToGenerator(function* (payload, next, end) {\n          try {\n            const {\n              error,\n              result\n            } = yield _this10.handleRequest(payload);\n            end(error, result);\n          } catch (error) {\n            end(error);\n          }\n        });\n\n        return function handleRequest(_x4, _x5, _x6) {\n          return _ref4.apply(this, arguments);\n        };\n      }(),\n      setEngine: _ => _\n    });\n  }\n\n  configWallet() {\n    var _this11 = this;\n\n    return {\n      getAccounts: function () {\n        var _ref5 = _asyncToGenerator(function* (cb) {\n          try {\n            const wc = yield _this11.getWalletConnector();\n            const accounts = wc.accounts;\n\n            if (accounts && accounts.length) {\n              cb(null, accounts);\n            } else {\n              cb(new Error(\"Failed to get accounts\"));\n            }\n          } catch (error) {\n            cb(error);\n          }\n        });\n\n        return function getAccounts(_x7) {\n          return _ref5.apply(this, arguments);\n        };\n      }(),\n      processMessage: function () {\n        var _ref6 = _asyncToGenerator(function* (msgParams, cb) {\n          try {\n            const wc = yield _this11.getWalletConnector();\n            const result = yield wc.signMessage([msgParams.from, msgParams.data]);\n            cb(null, result);\n          } catch (error) {\n            cb(error);\n          }\n        });\n\n        return function processMessage(_x8, _x9) {\n          return _ref6.apply(this, arguments);\n        };\n      }(),\n      processPersonalMessage: function () {\n        var _ref7 = _asyncToGenerator(function* (msgParams, cb) {\n          try {\n            const wc = yield _this11.getWalletConnector();\n            const result = yield wc.signPersonalMessage([msgParams.data, msgParams.from]);\n            cb(null, result);\n          } catch (error) {\n            cb(error);\n          }\n        });\n\n        return function processPersonalMessage(_x10, _x11) {\n          return _ref7.apply(this, arguments);\n        };\n      }(),\n      processSignTransaction: function () {\n        var _ref8 = _asyncToGenerator(function* (txParams, cb) {\n          try {\n            const wc = yield _this11.getWalletConnector();\n            const result = yield wc.signTransaction(txParams);\n            cb(null, result);\n          } catch (error) {\n            cb(error);\n          }\n        });\n\n        return function processSignTransaction(_x12, _x13) {\n          return _ref8.apply(this, arguments);\n        };\n      }(),\n      processTransaction: function () {\n        var _ref9 = _asyncToGenerator(function* (txParams, cb) {\n          try {\n            const wc = yield _this11.getWalletConnector();\n            const result = yield wc.sendTransaction(txParams);\n            cb(null, result);\n          } catch (error) {\n            cb(error);\n          }\n        });\n\n        return function processTransaction(_x14, _x15) {\n          return _ref9.apply(this, arguments);\n        };\n      }(),\n      processTypedMessage: function () {\n        var _ref10 = _asyncToGenerator(function* (msgParams, cb) {\n          try {\n            const wc = yield _this11.getWalletConnector();\n            const result = yield wc.signTypedData([msgParams.from, msgParams.data]);\n            cb(null, result);\n          } catch (error) {\n            cb(error);\n          }\n        });\n\n        return function processTypedMessage(_x16, _x17) {\n          return _ref10.apply(this, arguments);\n        };\n      }()\n    };\n  }\n\n}\n\nexport default WalletConnectProvider;","map":{"version":3,"sources":["/Users/advityasood/jude_anyft/node_modules/@walletconnect/web3-provider/dist/esm/index.js"],"names":["WalletConnect","QRCodeModal","HttpConnection","payloadId","signingMethods","parsePersonalSign","getRpcUrl","ProviderEngine","require","CacheSubprovider","FixtureSubprovider","FilterSubprovider","HookedWalletSubprovider","NonceSubprovider","SubscriptionsSubprovider","WalletConnectProvider","constructor","opts","pollingInterval","bridge","qrcode","qrcodeModal","qrcodeModalOptions","undefined","rpc","infuraId","http","isConnecting","connected","connectCallbacks","accounts","chainId","rpcUrl","enable","wc","getWalletConnector","start","subscribeWalletConnector","Error","request","payload","send","callback","method","params","sendAsyncPromise","Object","assign","id","jsonrpc","sendAsync","onConnect","push","triggerConnect","result","length","forEach","connector","storageId","clientMeta","trim","initialize","isWalletConnect","walletMeta","peerMeta","disconnect","close","disableSessionCreation","killSession","onDisconnect","handleRequest","response","_","handleOtherRequests","formatResponse","error","emit","includes","startsWith","handleReadRequests","sendCustomRequest","Promise","resolve","reject","x","on","createSession","then","updateState","catch","session","stop","sessionParams","networkId","updateRpcUrl","custom","updateHttpConnection","addProvider","eth_hashrate","eth_mining","eth_syncing","net_listening","web3_clientVersion","configWallet","next","end","setEngine","getAccounts","cb","processMessage","msgParams","signMessage","from","data","processPersonalMessage","signPersonalMessage","processSignTransaction","txParams","signTransaction","processTransaction","sendTransaction","processTypedMessage","signTypedData"],"mappings":"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","sourcesContent":["import WalletConnect from \"@walletconnect/client\";\nimport QRCodeModal from \"@walletconnect/qrcode-modal\";\nimport HttpConnection from \"@walletconnect/http-connection\";\nimport { payloadId, signingMethods, parsePersonalSign, getRpcUrl } from \"@walletconnect/utils\";\nconst ProviderEngine = require(\"web3-provider-engine\");\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\nclass WalletConnectProvider extends ProviderEngine {\n    constructor(opts) {\n        super({ pollingInterval: opts.pollingInterval || 8000 });\n        this.bridge = \"https://bridge.walletconnect.org\";\n        this.qrcode = true;\n        this.qrcodeModal = QRCodeModal;\n        this.qrcodeModalOptions = undefined;\n        this.rpc = null;\n        this.infuraId = \"\";\n        this.http = null;\n        this.isConnecting = false;\n        this.connected = false;\n        this.connectCallbacks = [];\n        this.accounts = [];\n        this.chainId = 1;\n        this.rpcUrl = \"\";\n        this.enable = async () => {\n            const wc = await this.getWalletConnector();\n            if (wc) {\n                this.start();\n                this.subscribeWalletConnector();\n                return wc.accounts;\n            }\n            else {\n                throw new Error(\"Failed to connect to WalleConnect\");\n            }\n        };\n        this.request = async (payload) => {\n            return this.send(payload);\n        };\n        this.send = async (payload, callback) => {\n            if (typeof payload === \"string\") {\n                const method = payload;\n                let params = callback;\n                if (method === \"personal_sign\") {\n                    params = parsePersonalSign(params);\n                }\n                return this.sendAsyncPromise(method, params);\n            }\n            payload = Object.assign({ id: payloadId(), jsonrpc: \"2.0\" }, payload);\n            if (payload.method === \"personal_sign\") {\n                payload.params = parsePersonalSign(payload.params);\n            }\n            if (callback) {\n                this.sendAsync(payload, callback);\n                return;\n            }\n            return this.sendAsyncPromise(payload.method, payload.params);\n        };\n        this.onConnect = (callback) => {\n            this.connectCallbacks.push(callback);\n        };\n        this.triggerConnect = (result) => {\n            if (this.connectCallbacks && this.connectCallbacks.length) {\n                this.connectCallbacks.forEach(callback => callback(result));\n            }\n        };\n        this.bridge = opts.connector\n            ? opts.connector.bridge\n            : opts.bridge || \"https://bridge.walletconnect.org\";\n        this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n        this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;\n        this.qrcodeModalOptions = opts.qrcodeModalOptions;\n        this.wc =\n            opts.connector ||\n                new WalletConnect({\n                    bridge: this.bridge,\n                    qrcodeModal: this.qrcode ? this.qrcodeModal : undefined,\n                    qrcodeModalOptions: this.qrcodeModalOptions,\n                    storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,\n                    signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,\n                    clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta,\n                });\n        this.rpc = opts.rpc || null;\n        if (!this.rpc &&\n            (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n            throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n        }\n        this.infuraId = opts.infuraId || \"\";\n        this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;\n        this.initialize();\n    }\n    get isWalletConnect() {\n        return true;\n    }\n    get connector() {\n        return this.wc;\n    }\n    get walletMeta() {\n        return this.wc.peerMeta;\n    }\n    async disconnect() {\n        this.close();\n    }\n    async close() {\n        const wc = await this.getWalletConnector({ disableSessionCreation: true });\n        await wc.killSession();\n        await this.onDisconnect();\n    }\n    async handleRequest(payload) {\n        try {\n            let response;\n            let result = null;\n            const wc = await this.getWalletConnector();\n            switch (payload.method) {\n                case \"wc_killSession\":\n                    await this.close();\n                    result = null;\n                    break;\n                case \"eth_accounts\":\n                    result = wc.accounts;\n                    break;\n                case \"eth_coinbase\":\n                    result = wc.accounts[0];\n                    break;\n                case \"eth_chainId\":\n                    result = wc.chainId;\n                    break;\n                case \"net_version\":\n                    result = wc.chainId;\n                    break;\n                case \"eth_uninstallFilter\":\n                    this.sendAsync(payload, (_) => _);\n                    result = true;\n                    break;\n                default:\n                    response = await this.handleOtherRequests(payload);\n            }\n            if (response) {\n                return response;\n            }\n            return this.formatResponse(payload, result);\n        }\n        catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n    async handleOtherRequests(payload) {\n        if (!signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n            return this.handleReadRequests(payload);\n        }\n        const wc = await this.getWalletConnector();\n        const result = await wc.sendCustomRequest(payload);\n        return this.formatResponse(payload, result);\n    }\n    async handleReadRequests(payload) {\n        if (!this.http) {\n            const error = new Error(\"HTTP Connection not available\");\n            this.emit(\"error\", error);\n            throw error;\n        }\n        return this.http.send(payload);\n    }\n    formatResponse(payload, result) {\n        return {\n            id: payload.id,\n            jsonrpc: payload.jsonrpc,\n            result: result,\n        };\n    }\n    getWalletConnector(opts = {}) {\n        const { disableSessionCreation = false } = opts;\n        return new Promise((resolve, reject) => {\n            const wc = this.wc;\n            if (this.isConnecting) {\n                this.onConnect((x) => resolve(x));\n            }\n            else if (!wc.connected && !disableSessionCreation) {\n                this.isConnecting = true;\n                wc.on(\"modal_closed\", () => {\n                    reject(new Error(\"User closed modal\"));\n                });\n                wc.createSession({ chainId: this.chainId })\n                    .then(() => {\n                    wc.on(\"connect\", (error, payload) => {\n                        if (error) {\n                            this.isConnecting = false;\n                            return reject(error);\n                        }\n                        this.isConnecting = false;\n                        this.connected = true;\n                        if (payload) {\n                            this.updateState(payload.params[0]);\n                        }\n                        this.emit(\"connect\");\n                        this.triggerConnect(wc);\n                        resolve(wc);\n                    });\n                })\n                    .catch(error => {\n                    this.isConnecting = false;\n                    reject(error);\n                });\n            }\n            else {\n                if (!this.connected) {\n                    this.connected = true;\n                    this.updateState(wc.session);\n                }\n                resolve(wc);\n            }\n        });\n    }\n    async subscribeWalletConnector() {\n        const wc = await this.getWalletConnector();\n        wc.on(\"disconnect\", error => {\n            if (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this.onDisconnect();\n        });\n        wc.on(\"session_update\", (error, payload) => {\n            if (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this.updateState(payload.params[0]);\n        });\n    }\n    async onDisconnect() {\n        await this.stop();\n        this.emit(\"close\", 1000, \"Connection closed\");\n        this.emit(\"disconnect\", 1000, \"Connection disconnected\");\n        this.connected = false;\n    }\n    async updateState(sessionParams) {\n        const { accounts, chainId, networkId, rpcUrl } = sessionParams;\n        if (!this.accounts || (accounts && this.accounts !== accounts)) {\n            this.accounts = accounts;\n            this.emit(\"accountsChanged\", accounts);\n        }\n        if (!this.chainId || (chainId && this.chainId !== chainId)) {\n            this.chainId = chainId;\n            this.emit(\"chainChanged\", chainId);\n        }\n        if (!this.networkId || (networkId && this.networkId !== networkId)) {\n            this.networkId = networkId;\n            this.emit(\"networkChanged\", networkId);\n        }\n        this.updateRpcUrl(this.chainId, rpcUrl || \"\");\n    }\n    updateRpcUrl(chainId, rpcUrl = \"\") {\n        const rpc = { infuraId: this.infuraId, custom: this.rpc || undefined };\n        rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);\n        if (rpcUrl) {\n            this.rpcUrl = rpcUrl;\n            this.updateHttpConnection();\n        }\n        else {\n            this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n        }\n    }\n    updateHttpConnection() {\n        if (this.rpcUrl) {\n            this.http = new HttpConnection(this.rpcUrl);\n            this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n            this.http.on(\"error\", error => this.emit(\"error\", error));\n        }\n    }\n    sendAsyncPromise(method, params) {\n        return new Promise((resolve, reject) => {\n            this.sendAsync({\n                id: payloadId(),\n                jsonrpc: \"2.0\",\n                method,\n                params: params || [],\n            }, (error, response) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve(response.result);\n            });\n        });\n    }\n    initialize() {\n        this.updateRpcUrl(this.chainId);\n        this.addProvider(new FixtureSubprovider({\n            eth_hashrate: \"0x00\",\n            eth_mining: false,\n            eth_syncing: true,\n            net_listening: true,\n            web3_clientVersion: `WalletConnect/v1.x.x/javascript`,\n        }));\n        this.addProvider(new CacheSubprovider());\n        this.addProvider(new SubscriptionsSubprovider());\n        this.addProvider(new FilterSubprovider());\n        this.addProvider(new NonceSubprovider());\n        this.addProvider(new HookedWalletSubprovider(this.configWallet()));\n        this.addProvider({\n            handleRequest: async (payload, next, end) => {\n                try {\n                    const { error, result } = await this.handleRequest(payload);\n                    end(error, result);\n                }\n                catch (error) {\n                    end(error);\n                }\n            },\n            setEngine: (_) => _,\n        });\n    }\n    configWallet() {\n        return {\n            getAccounts: async (cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const accounts = wc.accounts;\n                    if (accounts && accounts.length) {\n                        cb(null, accounts);\n                    }\n                    else {\n                        cb(new Error(\"Failed to get accounts\"));\n                    }\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processMessage: async (msgParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signMessage([msgParams.from, msgParams.data]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processPersonalMessage: async (msgParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signPersonalMessage([msgParams.data, msgParams.from]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processSignTransaction: async (txParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signTransaction(txParams);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processTransaction: async (txParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.sendTransaction(txParams);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processTypedMessage: async (msgParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signTypedData([msgParams.from, msgParams.data]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n        };\n    }\n}\nexport default WalletConnectProvider;\n"]},"metadata":{},"sourceType":"module"}