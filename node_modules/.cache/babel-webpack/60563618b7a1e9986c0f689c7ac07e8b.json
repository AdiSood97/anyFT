{"ast":null,"code":"import _asyncToGenerator from \"/Users/advityasood/jude_anyft/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport merge from 'lodash.merge';\nimport logLevel, { levels } from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst log = logLevel.getLogger(\"http-helpers\");\nlog.setLevel(levels.INFO);\nlet apiKey = \"torus-default\";\nlet embedHost = \"\"; // #region API Keys\n\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\n\nfunction setEmbedHost(embedHost_) {\n  embedHost = embedHost_;\n}\n\nfunction clearEmbedHost() {\n  embedHost = \"\";\n}\n\nfunction getEmbedHost() {\n  return embedHost;\n}\n\nfunction setAPIKey(apiKey_) {\n  apiKey = apiKey_;\n}\n\nfunction clearAPIKey() {\n  apiKey = \"torus-default\";\n}\n\nfunction getAPIKey() {\n  return apiKey;\n} // #endregion\n\n\nfunction setLogLevel(level) {\n  log.setLevel(level);\n}\n\nfunction getApiKeyHeaders() {\n  const headers = {};\n  if (apiKey) headers[gatewayAuthHeader] = apiKey;\n  if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n  return headers;\n}\n\nfunction debugLogResponse(response) {\n  log.info(\"Response: \".concat(response.status, \" \").concat(response.statusText));\n  log.info(\"Url: \".concat(response.url));\n}\n\nconst promiseTimeout = (ms, promise) => {\n  const timeout = new Promise((resolve, reject) => {\n    const id = setTimeout(() => {\n      clearTimeout(id);\n      reject(new Error(\"Timed out in \".concat(ms, \"ms\")));\n    }, ms);\n  });\n  return Promise.race([promise, timeout]);\n};\n\nconst get = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (url) {\n    let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const defaultOptions = {\n      mode: \"cors\",\n      headers: {}\n    };\n\n    if (customOptions.useAPIKey) {\n      defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n\n    const options = merge(defaultOptions, options_, {\n      method: \"GET\"\n    });\n    const response = yield fetch(url, options);\n\n    if (response.ok) {\n      return response.json();\n    }\n\n    debugLogResponse(response);\n    throw response;\n  });\n\n  return function get(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst post = function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"POST\"\n  }); // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  return promiseTimeout(customOptions.timeout || 60000, fetch(url, options).then(response => {\n    if (response.ok) {\n      return response.json();\n    }\n\n    debugLogResponse(response);\n    throw response;\n  }));\n};\n\nconst patch = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json; charset=utf-8\"\n      }\n    }; // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n\n    if (customOptions.useAPIKey) {\n      defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n\n    const options = merge(defaultOptions, options_, {\n      method: \"PATCH\"\n    }); // deep merge changes the structure of form data and url encoded data ,\n    // so we should not deepmerge body data\n\n    if (customOptions.isUrlEncodedData) {\n      // for multipart request browser/client will add multipart content type\n      // along with multipart boundary , so for multipart request send\n      // content-type: undefined or send with multipart boundary if already known\n      options.body = data; // If url encoded data, this must not be the content type\n\n      if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n      options.body = JSON.stringify(data);\n    }\n\n    const response = yield fetch(url, options);\n\n    if (response.ok) {\n      return response.json();\n    }\n\n    debugLogResponse(response);\n    throw response;\n  });\n\n  return function patch(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst remove = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (url) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const defaultOptions = {\n      mode: \"cors\",\n      headers: {\n        \"Content-Type\": \"application/json; charset=utf-8\"\n      }\n    }; // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n\n    if (customOptions.useAPIKey) {\n      defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n    }\n\n    const options = merge(defaultOptions, options_, {\n      method: \"DELETE\"\n    });\n\n    if (customOptions.isUrlEncodedData) {\n      // for multipart request browser/client will add multipart content type\n      // along with multipart boundary , so for multipart request send\n      // content-type: undefined or send with multipart boundary if already known\n      options.body = data; // If url encoded data, this must not be the content type\n\n      if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n    } else {\n      options.body = JSON.stringify(data);\n    }\n\n    const response = yield fetch(url, options);\n\n    if (response.ok) {\n      return response.json();\n    }\n\n    debugLogResponse(response);\n    throw response;\n  });\n\n  return function remove(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nconst generateJsonRPCObject = (method, parameters) => ({\n  jsonrpc: \"2.0\",\n  method,\n  id: 10,\n  params: parameters\n});\n\nconst promiseRace = function (url, options) {\n  let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n  return Promise.race([get(url, options), new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"timed out\"));\n    }, timeout);\n  })]);\n};\n\nexport { clearAPIKey, clearEmbedHost, gatewayAuthHeader, gatewayEmbedHostHeader, generateJsonRPCObject, get, getAPIKey, getEmbedHost, patch, post, promiseRace, promiseTimeout, remove, setAPIKey, setEmbedHost, setLogLevel };","map":{"version":3,"sources":["/Users/advityasood/jude_anyft/node_modules/@toruslabs/http-helpers/dist/httpHelpers.esm.js"],"names":["_defineProperty","merge","logLevel","levels","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","log","getLogger","setLevel","INFO","apiKey","embedHost","gatewayAuthHeader","gatewayEmbedHostHeader","setEmbedHost","embedHost_","clearEmbedHost","getEmbedHost","setAPIKey","apiKey_","clearAPIKey","getAPIKey","setLogLevel","level","getApiKeyHeaders","headers","debugLogResponse","response","info","concat","status","statusText","url","promiseTimeout","ms","promise","timeout","Promise","resolve","reject","id","setTimeout","clearTimeout","Error","race","get","options_","undefined","customOptions","defaultOptions","mode","useAPIKey","options","method","fetch","ok","json","post","data","isUrlEncodedData","body","JSON","stringify","then","patch","remove","generateJsonRPCObject","parameters","jsonrpc","params","promiseRace"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport merge from 'lodash.merge';\nimport logLevel, { levels } from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst log = logLevel.getLogger(\"http-helpers\");\nlog.setLevel(levels.INFO);\nlet apiKey = \"torus-default\";\nlet embedHost = \"\"; // #region API Keys\n\nconst gatewayAuthHeader = \"x-api-key\";\nconst gatewayEmbedHostHeader = \"x-embed-host\";\nfunction setEmbedHost(embedHost_) {\n  embedHost = embedHost_;\n}\nfunction clearEmbedHost() {\n  embedHost = \"\";\n}\nfunction getEmbedHost() {\n  return embedHost;\n}\nfunction setAPIKey(apiKey_) {\n  apiKey = apiKey_;\n}\nfunction clearAPIKey() {\n  apiKey = \"torus-default\";\n}\nfunction getAPIKey() {\n  return apiKey;\n} // #endregion\n\nfunction setLogLevel(level) {\n  log.setLevel(level);\n}\n\nfunction getApiKeyHeaders() {\n  const headers = {};\n  if (apiKey) headers[gatewayAuthHeader] = apiKey;\n  if (embedHost) headers[gatewayEmbedHostHeader] = embedHost;\n  return headers;\n}\n\nfunction debugLogResponse(response) {\n  log.info(\"Response: \".concat(response.status, \" \").concat(response.statusText));\n  log.info(\"Url: \".concat(response.url));\n}\n\nconst promiseTimeout = (ms, promise) => {\n  const timeout = new Promise((resolve, reject) => {\n    const id = setTimeout(() => {\n      clearTimeout(id);\n      reject(new Error(\"Timed out in \".concat(ms, \"ms\")));\n    }, ms);\n  });\n  return Promise.race([promise, timeout]);\n};\nconst get = async function (url) {\n  let options_ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {}\n  };\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"GET\"\n  });\n  const response = await fetch(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst post = function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  };\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"POST\"\n  }); // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  return promiseTimeout(customOptions.timeout || 60000, fetch(url, options).then(response => {\n    if (response.ok) {\n      return response.json();\n    }\n\n    debugLogResponse(response);\n    throw response;\n  }));\n};\nconst patch = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  }; // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"PATCH\"\n  }); // deep merge changes the structure of form data and url encoded data ,\n  // so we should not deepmerge body data\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  const response = await fetch(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst remove = async function (url) {\n  let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options_ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let customOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const defaultOptions = {\n    mode: \"cors\",\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    }\n  }; // for multipart request browser/client will add multipart content type\n  // along with multipart boundary , so for multipart request send\n  // content-type: undefined or send with multipart boundary if already known\n\n  if (customOptions.useAPIKey) {\n    defaultOptions.headers = _objectSpread(_objectSpread({}, defaultOptions.headers), getApiKeyHeaders());\n  }\n\n  const options = merge(defaultOptions, options_, {\n    method: \"DELETE\"\n  });\n\n  if (customOptions.isUrlEncodedData) {\n    // for multipart request browser/client will add multipart content type\n    // along with multipart boundary , so for multipart request send\n    // content-type: undefined or send with multipart boundary if already known\n    options.body = data; // If url encoded data, this must not be the content type\n\n    if (options.headers[\"Content-Type\"] === \"application/json; charset=utf-8\") delete options.headers[\"Content-Type\"];\n  } else {\n    options.body = JSON.stringify(data);\n  }\n\n  const response = await fetch(url, options);\n\n  if (response.ok) {\n    return response.json();\n  }\n\n  debugLogResponse(response);\n  throw response;\n};\nconst generateJsonRPCObject = (method, parameters) => ({\n  jsonrpc: \"2.0\",\n  method,\n  id: 10,\n  params: parameters\n});\nconst promiseRace = function (url, options) {\n  let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60000;\n  return Promise.race([get(url, options), new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject(new Error(\"timed out\"));\n    }, timeout);\n  })]);\n};\n\nexport { clearAPIKey, clearEmbedHost, gatewayAuthHeader, gatewayEmbedHostHeader, generateJsonRPCObject, get, getAPIKey, getEmbedHost, patch, post, promiseRace, promiseTimeout, remove, setAPIKey, setEmbedHost, setLogLevel };\n"]},"metadata":{},"sourceType":"module"}